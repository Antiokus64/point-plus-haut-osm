<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Point le plus haut — OSM + IGN Topo</title>

<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

<style>
  html, body, #map { height: 100%; margin: 0; padding: 0; }
  .leaflet-control-container .leaflet-top { z-index: 1100; }
</style>
</head>
<body class="bg-slate-50 text-slate-800">

<div class="flex h-screen">
  <aside id="sidebar" class="w-96 p-4 border-r bg-white shadow-md z-20 overflow-auto">
    <h1 class="text-lg font-semibold mb-4">Trouver le point le plus haut</h1>

    <!-- Recherche lieu -->
    <div class="mb-3">
      <label class="block text-sm font-medium">Rechercher un lieu</label>
      <div class="flex gap-2 mt-2">
        <input id="searchInput" class="flex-1 px-3 py-2 border rounded" placeholder="Ville, adresse ou lieu...">
        <button id="searchBtn" class="px-3 py-2 bg-blue-600 text-white rounded">Rechercher</button>
      </div>
      <div id="searchResults" class="mt-2 text-xs text-slate-600"></div>
    </div>

    <!-- Options -->
    <div class="space-y-3">
      <div>
        <label class="block text-sm font-medium">Sélection (dessine un rectangle)</label>
        <p class="text-xs text-slate-500 mt-1">Utilise l'outil de dessin sur la carte à droite. Garde une seule sélection active.</p>
      </div>

      <div class="pt-2 border-t">
        <label class="inline-flex items-center">
          <input id="useGrid" type="checkbox" class="mr-2">
          <span class="text-sm">Échantillonner la zone avec SRTM si OSM n'a pas d'élévation</span>
        </label>
        <div class="mt-2 flex items-center gap-2">
          <label class="text-xs">Résolution</label>
          <input id="gridSize" type="number" min="6" max="80" value="15" class="w-20 px-2 py-1 border rounded">
          <span class="text-xs text-slate-500">(plus = plus précis)</span>
        </div>

        <label class="inline-flex items-center mt-3">
          <input id="mergeOSMTop" type="checkbox" class="mr-2" checked>
          <span class="text-sm">Fusionner OSM + SRTM (préférence OSM si disponible)</span>
        </label>

        <label class="inline-flex items-center mt-3">
          <input id="filterOutliers" type="checkbox" class="mr-2" checked>
          <span class="text-sm">Filtrer les valeurs aberrantes (tolérance automatique)</span>
        </label>
      </div>

      <!-- Styles -->
      <div class="pt-2 border-t">
        <label class="block text-sm font-medium">Style</label>
        <div class="mt-2 grid grid-cols-3 gap-2">
          <button class="styleBtn px-2 py-2 rounded border" data-style="Pro">Pro</button>
          <button class="styleBtn px-2 py-2 rounded border" data-style="Nature">Nature</button>
          <button class="styleBtn px-2 py-2 rounded border" data-style="Dark">Dark</button>
        </div>
      </div>

      <!-- Fond de carte -->
      <div class="pt-2 border-t">
        <label class="block text-sm font-medium">Fond de carte</label>
        <div class="mt-2 grid grid-cols-2 gap-2">
          <button class="basemapBtn px-2 py-2 rounded border" data-layer="osm">OSM Standard</button>
          <button class="basemapBtn px-2 py-2 rounded border" data-layer="bdtopo">BD TOPO (IGN)</button>
          <button class="basemapBtn px-2 py-2 rounded border" data-layer="rgealti">RGE ALTI (IGN)</button>
        </div>
      </div>

      <!-- Actions -->
      <div class="pt-2 border-t">
        <div class="flex gap-2">
          <button id="locateBtn" class="flex-1 px-3 py-2 rounded bg-emerald-600 text-white">Ma position</button>
          <button id="resetBtn" class="px-3 py-2 rounded border">Reset</button>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-2">
          <button id="findBtn" class="px-3 py-2 bg-blue-600 text-white rounded">Trouver le point le plus haut</button>
          <button id="exportBtn" class="px-3 py-2 bg-slate-700 text-white rounded">Exporter (CSV / GeoJSON)</button>
        </div>

        <div id="status" class="mt-3 text-sm font-medium">Prêt.</div>
        <div id="log" class="mt-2 text-xs text-slate-600 max-h-36 overflow-auto"></div>

        <div class="pt-4 border-t mt-4">
          <button onclick="window.print()" class='w-full px-3 py-2 rounded bg-indigo-600 text-white'>Imprimer l'aide</button>
        </div>
      </div>
    </div>
  </aside>

  <main class="flex-1 relative">
    <div id="map" style="width:100%; height:100%"></div>
  </main>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://unpkg.com/leaflet-tilelayer-wmts/leaflet-tilelayer-wmts.js"></script>

<script>
const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
const OPENTOPODATA_URL = 'https://api.opentopodata.org/v1/srtm90m';
const NOMINATIM_URL = 'https://nominatim.openstreetmap.org/search?format=json&limit=6&q=';

// Fond de carte
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' });

// Flux WMTS IGN (libre)
const wmtsUrl = 'https://data.geopf.fr/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetCapabilities';
const bdTopo = L.tileLayer.wmts(wmtsUrl, {
  layer: 'HYDROGRAPHY.HYDROGRAPHY',
  style: 'default',
  tilematrixSet: 'PM',
  format: 'image/png',
  attribution: '© IGN BD TOPO'
});
const rgeAlti = L.tileLayer.wmts(wmtsUrl, {
  layer: 'ELEVATION.ELEVATIONGRIDCOVERAGE',
  style: 'default',
  tilematrixSet: 'PM',
  format: 'image/png',
  attribution: '© IGN RGE ALTI'
});

const baseMaps = { osm, bdTopo, rgeAlti };

const map = L.map('map', { layers: [osm] }).setView([46.8,2.4],6);

// Draw rectangle
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);
const drawControl = new L.Control.Draw({
  draw: { polygon:false, polyline:false, circle:false, marker:false, rectangle:{ shapeOptions:{ color:'#f06eaa' } } },
  edit: { featureGroup: drawnItems }
});
map.addControl(drawControl);
map.on(L.Draw.Event.CREATED, e => { drawnItems.clearLayers(); drawnItems.addLayer(e.layer); });

// Styles
document.querySelectorAll('.styleBtn').forEach(b=>b.addEventListener('click', ()=>{
  const s=b.dataset.style||'Pro';
  document.body.className = s==='Pro'?'bg-slate-50 text-slate-800':s==='Nature'?'bg-emerald-50 text-emerald-900':'bg-slate-900 text-slate-200';
}));

// Basemap switch
document.querySelectorAll('.basemapBtn').forEach(b=>b.addEventListener('click',()=>{
  const l=b.dataset.layer;
  Object.values(baseMaps).forEach(layer=>map.removeLayer(layer));
  map.addLayer(baseMaps[l]);
}));

// Search
const searchInput=document.getElementById('searchInput');
const searchBtn=document.getElementById('searchBtn');
const searchResultsEl=document.getElementById('searchResults');
let lastSearchMarker=null;
searchBtn.addEventListener('click', async ()=>{
  const q=searchInput.value.trim(); if(!q) return;
  try{
    const r=await fetch(NOMINATIM_URL+encodeURIComponent(q));
    const j=await r.json(); searchResultsEl.innerHTML='';
    if(j.length===0){ searchResultsEl.innerText='Aucun résultat.'; return; }
    j.forEach(it=>{ const btn=document.createElement('button'); btn.className='w-full text-left px-2 py-1 hover:bg-slate-100 rounded text-sm';
      btn.innerText=it.display_name+' ('+it.lat+','+it.lon+')';
      btn.addEventListener('click',()=>{
        if(lastSearchMarker) map.removeLayer(lastSearchMarker);
        lastSearchMarker=L.marker([it.lat,it.lon]).addTo(map).bindPopup(it.display_name).openPopup();
        map.setView([it.lat,it.lon],13); searchResultsEl.innerHTML='';
      });
      searchResultsEl.appendChild(btn);
    });
  }catch(e){ console.error(e); }
});

// Point le plus haut & export
let resultMarker=null;
let lastResult=null;
document.getElementById('findBtn').addEventListener('click', async ()=>{
  if(drawnItems.getLayers().length===0){ alert('Dessine d\'abord un rectangle.'); return; }
  drawnItems.eachLayer(layer=>{ const bounds=layer.getBounds(); processBBox(bounds); });
});

async function processBBox(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const query='[out:json][timeout:60]; ( node["natural"="peak"]('+s+','+w+','+n+','+e+'); node["ele"]('+s+','+w+','+n+','+e+'); ); out body;';
  try{
    const resp=await fetch(OVERPASS_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8'},body:'data='+encodeURIComponent(query)});
    const data=await resp.json();
    let osmHighest=null;
    data.elements.forEach(el=>{ if(el.type!=='node') return; const tags=el.tags||{};
      if(tags.ele!==undefined){ const num=parseFloat(tags.ele.toString().replace(',','.'));
        if(!isNaN(num)&&( !osmHighest||num>osmHighest.ele)) osmHighest={ele:num, lat:el.lat, lon:el.lon, name:tags.name||'Inconnu'}; }
    });

    const useGrid=document.getElementById('useGrid').checked;
    const gridSize=Math.max(6, Math.min(80, parseInt(document.getElementById('gridSize').value)||15));
    let topoHighest=null;
    if(useGrid){
      const latStep=(n-s)/(gridSize-1); const lonStep=(e-w)/(gridSize-1);
      const locs=[];
      for(let i=0;i<gridSize;i++){ for(let j=0;j<gridSize;j++){ locs.push([ (s+i*latStep).toFixed(6), (w+j*lonStep).toFixed(6) ]); } }
      const batchSize=80;
      for(let idx=0;idx<locs.length;idx+=batchSize){ const batch=locs.slice(idx,idx+batchSize);
        let locationsParam=''; batch.forEach((b,k)=>{ if(k) locationsParam+='|'; locationsParam+=b[0]+','+b[1]; });
        const r=await fetch(OPENTOPODATA_URL+'?locations='+encodeURIComponent(locationsParam));
        const jr=await r.json();
        jr.results.forEach(res=>{ if(res&&typeof res.elevation==='number'&&(!topoHighest||res.elevation>topoHighest.ele)) topoHighest={ele:res.elevation, lat:res.location[0], lon:res.location[1]}; });
        await new Promise(r=>setTimeout(r,250));
      }
    }

    let final=null;
    if(osmHighest && topoHighest){ final=osmHighest.ele>=topoHighest.ele?osmHighest:topoHighest; }
    else final=osmHighest||topoHighest;

    if(!final){ alert('Aucune élévation trouvée.'); return; }
    showResult(final);
    lastResult=final;
  }catch(err){ console.error(err); alert('Erreur: '+err.message); }
}

function showResult(res){
  if(resultMarker) map.removeLayer(resultMarker);
  resultMarker=L.marker([res.lat,res.lon]).addTo(map);
  const popup='<b>'+ (res.name||'Point')+'</b><br/>Altitude: '+res.ele+' m<br/>Coord: '+res.lat.toFixed(6)+','+res.lon.toFixed(6);
  resultMarker.bindPopup(popup).openPopup();
  map.setView([res.lat,res.lon],13);
}

document.getElementById('exportBtn').addEventListener('click',()=>{
  if(!lastResult){ alert('Aucun résultat à exporter'); return; }
  const csv='name,ele,lat,lon\n\"'+(lastResult.name||'Point')+'\",\"'+lastResult.ele+'\",\"'+lastResult.lat+'\",\"'+lastResult.lon+'\"';
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='highest_point.csv'; a.click();
});
</script>
</body>
</html>
